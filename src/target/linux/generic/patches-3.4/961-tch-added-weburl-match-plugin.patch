--- /dev/null
+++ b/include/linux/netfilter/xt_weburl.h
@@ -0,0 +1,45 @@
+/*  weburl --	A netfilter module to match URLs in HTTP requests
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright © 2008 by Eric Bishop <eric@gargoyle-router.com>
+ *
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+
+
+#ifndef _XT_WEBURL_H
+#define _XT_WEBURL_H
+
+
+#define MAX_TEST_STR 1024
+
+#define WEBURL_CONTAINS_TYPE 1
+#define WEBURL_REGEX_TYPE 2
+#define WEBURL_EXACT_TYPE 3
+#define WEBURL_ALL_PART 4
+#define WEBURL_DOMAIN_PART 5
+#define WEBURL_PATH_PART 6
+
+struct ipt_weburl_info
+{
+	char test_str[MAX_TEST_STR];
+	unsigned char match_type;
+	unsigned char match_part;
+	unsigned char invert;
+};
+#endif /*_XT_WEBURL_H*/
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -1240,6 +1240,12 @@ config NETFILTER_XT_MATCH_U32
 
 	  Details and examples are in the kernel module source.
 
+config NETFILTER_XT_MATCH_WEBURL
+	tristate '"weburl" match support'
+	depends on NETFILTER_ADVANCED
+	---help---
+	This is a WEB URL filter match option for parental control.
+
 endif # NETFILTER_XTABLES
 
 endmenu
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -131,6 +131,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TIME) += xt_time.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_U32) += xt_u32.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_WEBURL) += xt_weburl.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/
diff --git a/kernel/linux-3.4rt/net/netfilter/weburl_deps/tree_map.h b/kernel/linux-3.4rt/net/netfilter/weburl_deps/tree_map.h
--- /dev/null
+++ b/net/netfilter/weburl_deps/tree_map.h
@@ -0,0 +1,1084 @@
+/*
+ * Copyright © 2008 by Eric Bishop <eric@gargoyle-router.com>
+ *
+ * This work 'as-is' we provide.
+ * No warranty, express or implied.
+ * We've done our best,
+ * to debug and test.
+ * Liability for damages denied.
+ *
+ * Permission is granted hereby,
+ * to copy, share, and modify.
+ * Use as is fit,
+ * free or for profit.
+ * On this notice these rights rely.
+ *
+ *
+ *
+ *  Note that unlike other portions of Gargoyle this code
+ *  does not fall under the GPL, but the rather whimsical
+ *  'Poetic License' above.
+ *
+ *  Basically, this library contains a bunch of utilities
+ *  that I find useful.  I'm sure other libraries exist
+ *  that are just as good or better, but I like these tools
+ *  because I personally wrote them, so I know their quirks.
+ *  (i.e. I know where the bodies are buried).  I want to
+ *  make sure that I can re-use these utilities for whatever
+ *  code I may want to write in the future be it
+ *  proprietary or open-source, so I've put them under
+ *  a very, very permissive license.
+ *
+ *  If you find this code useful, use it.  If not, don't.
+ *  I really don't care.
+ *
+ */
+
+
+#if __KERNEL__
+	#define malloc(foo)	kmalloc(foo,GFP_ATOMIC)
+	#define free(foo)	kfree(foo)
+	#define printf(format,args...)	printk(format,##args)
+
+	/* kernel strdup */
+	static inline char *kernel_strdup(const char *str);
+	static inline char *kernel_strdup(const char *str)
+	{
+		char *tmp;
+		long int s;
+		s=strlen(str) + 1;
+		tmp = kmalloc(s, GFP_ATOMIC);
+		if (tmp != NULL)
+		{
+			memcpy(tmp, str, s);
+		}
+		return tmp;
+	}
+	#define strdup kernel_strdup
+
+#endif
+
+
+
+/* tree_map structs / prototypes */
+typedef struct long_tree_map_node
+{
+	unsigned long key;
+	void* value;
+
+	signed char balance;
+	struct long_tree_map_node* left;
+	struct long_tree_map_node* right;
+} long_map_node;
+
+typedef struct 
+{
+	long_map_node* root;
+	unsigned long num_elements;
+
+}long_map;
+
+typedef struct
+{
+	long_map lm;
+	unsigned char store_keys;
+	unsigned long num_elements;
+
+}string_map;
+
+
+
+/* long map functions */
+long_map* initialize_long_map(void);
+void* get_long_map_element(long_map* map, unsigned long key);
+void* get_smallest_long_map_element(long_map* map, unsigned long* smallest_key);
+void* get_largest_long_map_element(long_map* map, unsigned long* largest_key);
+void* remove_smallest_long_map_element(long_map* map, unsigned long* smallest_key);
+void* remove_largest_long_map_element(long_map* map, unsigned long* largest_key);
+void* set_long_map_element(long_map* map, unsigned long key, void* value);
+void* remove_long_map_element(long_map* map, unsigned long key);
+unsigned long* get_sorted_long_map_keys(long_map* map, unsigned long* num_keys_returned);
+void** get_sorted_long_map_values(long_map* map, unsigned long* num_values_returned);
+void** destroy_long_map(long_map* map, int destruction_type, unsigned long* num_destroyed);
+void apply_to_every_long_map_value(long_map* map, void (*apply_func)(unsigned long key, void* value));
+
+/* string map functions */
+string_map* initialize_string_map(unsigned char store_keys);
+void* get_string_map_element(string_map* map, const char* key);
+void* set_string_map_element(string_map* map, const char* key, void* value);
+void* remove_string_map_element(string_map* map, const char* key);
+char** get_string_map_keys(string_map* map, unsigned long* num_keys_returned); 
+void** get_string_map_values(string_map* map, unsigned long* num_values_returned);
+void** destroy_string_map(string_map* map, int destruction_type, unsigned long* num_destroyed);
+void apply_to_every_string_map_value(string_map* map, void (*apply_func)(char* key, void* value));
+
+
+/*
+ * three different ways to deal with values when data structure is destroyed
+ */
+#define DESTROY_MODE_RETURN_VALUES	20
+#define DESTROY_MODE_FREE_VALUES 	21
+#define DESTROY_MODE_IGNORE_VALUES	22
+
+
+/* 
+ * for convenience & backwards compatibility alias _string_map_ functions to 
+ *  _map_ functions since string map is used more often than long map
+ */
+#define initialize_map		initialize_string_map
+#define set_map_element		set_string_map_element
+#define get_map_element		get_string_map_element
+#define remove_map_element	remove_string_map_element
+#define get_map_keys		get_string_map_keys
+#define get_map_values		get_string_map_values
+#define destroy_map		destroy_string_map
+
+
+/* internal utility structures/ functions */
+typedef struct stack_node_struct
+{
+	long_map_node** node_ptr;
+	signed char direction;
+	struct stack_node_struct* previous;
+} stack_node;
+
+static void free_stack(stack_node* stack);
+static void** destroy_long_map_values(long_map* map, int destruction_type, unsigned long* num_destroyed);
+static void apply_to_every_long_map_node(long_map_node* node, void (*apply_func)(unsigned long key, void* value));
+static void apply_to_every_string_map_node(long_map_node* node, unsigned char has_key, void (*apply_func)(char* key, void* value));
+static void get_sorted_node_keys(long_map_node* node, unsigned long* key_list, unsigned long* next_key_index, int depth);
+static void get_sorted_node_values(long_map_node* node, void** value_list, unsigned long* next_value_index, int depth);
+static signed char rebalance (long_map_node** n, signed char direction, signed char update_op);
+static void rotate_right (long_map_node** parent);
+static void rotate_left (long_map_node** parent);
+
+/* internal for string map */
+typedef struct 
+{
+	char* key;
+	void* value;
+} string_map_key_value;
+static unsigned long sdbm_string_hash(const char *key);
+
+
+
+
+/***************************************************
+ * For testing only
+ ***************************************************/
+/*
+void print_list(stack_node *l);
+
+void print_list(stack_node *l)
+{
+	if(l != NULL)
+	{
+		printf(" list key = %ld, dir=%d, \n", (*(l->node_ptr))->key, l->direction);
+		print_list(l->previous);
+	}
+}
+*/
+/******************************************************
+ * End testing Code
+ *******************************************************/
+
+
+
+
+/***************************************************
+ * string_map function definitions
+ ***************************************************/
+
+string_map* initialize_string_map(unsigned char store_keys)
+{
+	string_map* map = (string_map*)malloc(sizeof(string_map));
+	if(map != NULL)
+	{
+		map->store_keys = store_keys;
+		map->lm.root = NULL;
+		map->lm.num_elements = 0;
+		map->num_elements = map->lm.num_elements;
+	}
+	return map;
+}
+
+void* get_string_map_element(string_map* map, const char* key)
+{
+	unsigned long hashed_key = sdbm_string_hash(key);
+	void* return_value =  get_long_map_element( &(map->lm), hashed_key);
+	if(return_value != NULL && map->store_keys)
+	{
+		string_map_key_value* r = (string_map_key_value*)return_value;
+		return_value = r->value;
+	}
+	map->num_elements = map->lm.num_elements;
+	return return_value;
+}
+
+void* set_string_map_element(string_map* map, const char* key, void* value)
+{
+	unsigned long hashed_key = sdbm_string_hash(key);
+	void* return_value = NULL;
+	if(map->store_keys)
+	{
+		string_map_key_value* kv = (string_map_key_value*)malloc(sizeof(string_map_key_value));
+		if(kv == NULL) /* deal with malloc failure */
+		{
+			return NULL;
+		}
+		kv->key = strdup(key);
+		if(kv->key == NULL) /* deal with malloc failure */
+		{
+			free(kv);
+			return NULL;
+		}
+		kv->value = value;
+		return_value = set_long_map_element(  &(map->lm), hashed_key, kv);
+		if(return_value != NULL)
+		{
+			string_map_key_value* r = (string_map_key_value*)return_value;
+			return_value = r->value;
+			free(r->key);
+			free(r);
+		}
+	}
+	else
+	{
+		return_value = set_long_map_element( &(map->lm), hashed_key, value);
+	}
+	map->num_elements = map->lm.num_elements;
+	return return_value;
+}
+
+void* remove_string_map_element(string_map* map, const char* key)
+{
+	unsigned long hashed_key = sdbm_string_hash(key);
+	void* return_value =  remove_long_map_element( &(map->lm), hashed_key);
+	
+	if(return_value != NULL && map->store_keys)
+	{
+		string_map_key_value* r = (string_map_key_value*)return_value;
+		return_value = r->value;
+		free(r->key);
+		free(r);
+	}
+	map->num_elements = map->lm.num_elements;
+	return return_value;
+}
+
+char** get_string_map_keys(string_map* map, unsigned long* num_keys_returned)
+{
+	char** str_keys;
+	str_keys = (char**)malloc((map->num_elements+1)*sizeof(char*));
+	if(str_keys == NULL) /* deal with malloc failure */
+	{
+		return NULL;
+	}
+	str_keys[0] = NULL;
+	*num_keys_returned = 0;
+	if(map->store_keys && map->num_elements > 0)
+	{
+		unsigned long list_length;
+		void** long_values = get_sorted_long_map_values( &(map->lm),  &list_length);
+		unsigned long key_index;
+		/*list_length will be 0 on malloc failure in get_sorted_long_map_values, so this code shouldn't seg fault if that happens */
+		for(key_index = 0; key_index < list_length; key_index++) 
+		{
+			str_keys[key_index] = strdup( ((string_map_key_value*)(long_values[key_index]))->key);
+			if(str_keys[key_index] == NULL) /* deal with malloc failure */
+			{
+				//just return the incomplete list (hey, it's null terminated...)
+				free(long_values);
+				return str_keys;
+			}
+			*num_keys_returned = *num_keys_returned + 1;
+		}
+		str_keys[list_length] = NULL;
+		free(long_values);
+	}
+	return str_keys;
+}
+
+
+void** get_string_map_values(string_map* map, unsigned long* num_values_returned)
+{
+	void** values = NULL;
+	if(map != NULL)
+	{
+		values = get_sorted_long_map_values ( &(map->lm), num_values_returned );
+	}
+	return values;
+}
+
+
+void** destroy_string_map(string_map* map, int destruction_type, unsigned long* num_destroyed)
+{
+	void** return_values = NULL;
+	if(map != NULL)
+	{
+		if(map->store_keys)
+		{
+			void** kvs = destroy_long_map_values( &(map->lm), DESTROY_MODE_RETURN_VALUES, num_destroyed );
+			unsigned long kv_index = 0;
+			for(kv_index=0; kv_index < *num_destroyed; kv_index++)
+			{
+				string_map_key_value* kv = (string_map_key_value*)kvs[kv_index];
+				void* value = kv->value;
+				
+				free(kv->key);
+				free(kv);
+				if(destruction_type == DESTROY_MODE_FREE_VALUES)
+				{
+					free(value);
+				}
+				if(destruction_type == DESTROY_MODE_RETURN_VALUES)
+				{
+					kvs[kv_index] = value;
+				}
+			}
+			if(destruction_type == DESTROY_MODE_RETURN_VALUES)
+			{
+				return_values = kvs;
+			}
+			else
+			{
+				free(kvs);
+			}
+		}
+		else
+		{
+			return_values = destroy_long_map_values( &(map->lm), destruction_type, num_destroyed );
+		}
+		free(map);
+	}
+	return return_values;
+}
+
+
+
+
+/***************************************************
+ * long_map function definitions
+ ***************************************************/
+
+long_map* initialize_long_map(void)
+{
+	long_map* map = (long_map*)malloc(sizeof(long_map));
+	if(map != NULL) /* test for malloc failure */
+	{
+		map->root = NULL;
+		map->num_elements = 0;
+	}
+	return map;
+}
+
+void* get_long_map_element(long_map* map, unsigned long key)
+{
+	void* value = NULL;
+
+	if(map->root != NULL)
+	{
+		long_map_node* parent_node = map->root;
+		long_map_node* next_node;	
+		while( key != parent_node->key && (next_node = (long_map_node *)(key < parent_node->key ? parent_node->left : parent_node->right))  != NULL)
+		{
+			parent_node = next_node;
+		}
+		if(parent_node->key == key)
+		{
+			value = parent_node->value;
+		}
+	}
+	return value;
+}
+
+void* get_smallest_long_map_element(long_map* map, unsigned long* smallest_key)
+{
+	void* value = NULL;
+	if(map->root != NULL)
+	{
+		long_map_node* next_node = map->root;	
+		while( next_node->left != NULL)
+		{
+			next_node = next_node->left;
+		}
+		value = next_node->value;
+		*smallest_key = next_node->key;
+	}
+	return value;
+}
+
+void* get_largest_long_map_element(long_map* map, unsigned long* largest_key)
+{
+	void* value = NULL;
+	if(map->root != NULL)
+	{
+		long_map_node* next_node = map->root;	
+		while( next_node->right != NULL)
+		{
+			next_node = next_node->right;
+		}
+		value = next_node->value;
+		*largest_key = next_node->key;
+	}
+	return value;
+}
+
+void* remove_smallest_long_map_element(long_map* map, unsigned long* smallest_key)
+{
+	get_smallest_long_map_element(map, smallest_key);
+	return remove_long_map_element(map, *smallest_key);
+}
+
+void* remove_largest_long_map_element(long_map* map, unsigned long* largest_key)
+{
+	get_largest_long_map_element(map, largest_key);
+	return remove_long_map_element(map, *largest_key);
+}
+
+
+/* if replacement performed, returns replaced value, otherwise null */
+void* set_long_map_element(long_map* map, unsigned long key, void* value)
+{
+	stack_node* parent_list = NULL;
+	void* old_value = NULL;
+	int old_value_found = 0;
+
+	long_map_node* parent_node;
+	long_map_node* next_node;
+	stack_node* next_parent;
+	stack_node* previous_parent;
+	signed char new_balance;
+
+
+	long_map_node* new_node = (long_map_node*)malloc(sizeof(long_map_node));
+	if(new_node == NULL)
+	{
+		return NULL;
+	}
+	new_node->value = value;
+	new_node->key = key;
+	new_node->left = NULL;
+	new_node->right = NULL;
+	new_node->balance = 0;
+
+	
+
+	if(map->root == NULL)
+	{
+		map->root = new_node;	
+	}
+	else
+	{
+		parent_node = map->root;
+			
+		next_parent = (stack_node*)malloc(sizeof(stack_node));
+		if(next_parent == NULL) /* deal with malloc failure */
+		{
+			free(new_node);
+			return NULL; /* won't insert but won't seg fault */
+		}
+		next_parent->node_ptr =  &(map->root);
+		next_parent->previous = parent_list;
+		parent_list = next_parent;	
+			
+		while( key != parent_node->key && (next_node = (key < parent_node->key ? parent_node->left : parent_node->right) )  != NULL)
+		{
+			next_parent = (stack_node*)malloc(sizeof(stack_node));
+			if(next_parent == NULL) /* deal with malloc failure */
+			{
+				/* free previous stack nodes to prevent memory leak */
+				free_stack(parent_list);
+				free(new_node);
+				return NULL;
+			}
+			next_parent->node_ptr = key < parent_node->key ? &(parent_node->left) : &(parent_node->right);
+			next_parent->previous = parent_list;
+			next_parent->previous->direction = key < parent_node->key ? -1 : 1;
+			parent_list = next_parent;
+
+			parent_node = next_node;
+		}
+		
+		
+		if(key == parent_node->key)
+		{
+			old_value = parent_node->value;
+			old_value_found = 1;
+			parent_node->value = value;
+			free(new_node);
+			/* we merely replaced a node, no need to rebalance */
+		}
+		else
+		{	
+			if(key < parent_node->key)
+			{
+				parent_node->left = (void*)new_node;
+				parent_list->direction = -1;
+			}
+			else
+			{
+				parent_node->right = (void*)new_node;
+				parent_list->direction = 1;
+			}
+			
+			
+			/* we inserted a node, rebalance */
+			previous_parent = parent_list;
+			new_balance  = 1; /* initial value is not used, but must not be 0 for initial loop condition */
+			
+			
+			while(previous_parent != NULL && new_balance != 0)
+			{
+				new_balance = rebalance(previous_parent->node_ptr, previous_parent->direction, 1);
+				previous_parent = previous_parent->previous;
+			}
+		}
+	}
+
+	free_stack(parent_list);
+
+	if(old_value_found == 0)
+	{
+		map->num_elements = map->num_elements + 1;
+	}
+
+	return old_value;
+}
+
+
+void* remove_long_map_element(long_map* map, unsigned long key)
+{
+
+	void* value = NULL;
+	
+	long_map_node* root_node = map->root;	
+	stack_node* parent_list = NULL;
+
+
+	long_map_node* remove_parent;
+	long_map_node* remove_node;
+	long_map_node* next_node;
+
+	long_map_node* replacement;
+	long_map_node* replacement_parent;
+	long_map_node* replacement_next;
+
+	stack_node* next_parent;
+	stack_node* previous_parent;
+	stack_node* replacement_stack_node;
+
+
+	signed char new_balance;
+
+
+
+	if(root_node != NULL)
+	{
+		remove_parent = root_node;
+		remove_node = key < remove_parent->key ? remove_parent->left : remove_parent->right;
+		
+		if(remove_node != NULL && key != remove_parent->key)
+		{
+			next_parent = (stack_node*)malloc(sizeof(stack_node));
+			if(next_parent == NULL) /* deal with malloc failure */
+			{
+				return NULL;
+			}
+			next_parent->node_ptr =  &(map->root);
+			next_parent->previous = parent_list;
+			parent_list = next_parent;	
+			while( key != remove_node->key && (next_node = (key < remove_node->key ? remove_node->left : remove_node->right))  != NULL)
+			{
+				next_parent = (stack_node*)malloc(sizeof(stack_node));
+				if(next_parent == NULL) /* deal with malloc failure */
+				{
+					/* free previous stack nodes to prevent memory leak */
+					free_stack(parent_list);
+					return NULL;
+				}
+				next_parent->node_ptr = key < remove_parent->key ? &(remove_parent->left) : &(remove_parent->right);
+				next_parent->previous = parent_list;
+				next_parent->previous->direction = key < remove_parent->key ? -1 : 1; 
+				parent_list = next_parent;
+				
+				
+				remove_parent = remove_node;
+				remove_node = next_node;
+			}
+			parent_list->direction = key < remove_parent-> key ? -1 : 1;
+		}
+		else
+		{
+			remove_node = remove_parent;
+		}
+
+
+		if(key == remove_node->key)
+		{
+			
+			/* find replacement for node we are deleting */
+			if( remove_node->right == NULL )
+			{
+				replacement = remove_node->left;
+			}
+			else if( remove_node->right->left == NULL)
+			{
+
+				replacement = remove_node->right;
+				replacement->left = remove_node->left;
+				replacement->balance = remove_node->balance;
+
+				/* put pointer to replacement node into list for balance update */
+				replacement_stack_node = (stack_node*)malloc(sizeof(stack_node));
+				if(replacement_stack_node == NULL) /* deal with malloc failure */
+				{
+					/* free previous stack nodes to prevent memory leak */
+					free_stack(parent_list);
+					return NULL;
+				}
+				replacement_stack_node->previous = parent_list;
+				replacement_stack_node->direction = 1; /* replacement is from right */
+				if(remove_node == remove_parent) /* special case for root node */
+				{
+					replacement_stack_node->node_ptr = &(map->root);
+				}
+				else
+				{
+					replacement_stack_node->node_ptr = key < remove_parent-> key ? &(remove_parent->left) : &(remove_parent->right);
+				}
+				parent_list = replacement_stack_node;
+
+			}
+			else
+			{
+				/* put pointer to replacement node into list for balance update */
+				replacement_stack_node = (stack_node*)malloc(sizeof(stack_node));
+				if(replacement_stack_node == NULL) /* deal with malloc failure */
+				{
+					/* free previous stack nodes to prevent memory leak */
+					free_stack(parent_list);
+					return NULL;
+				}
+
+				replacement_stack_node->previous = parent_list;
+				replacement_stack_node->direction = 1; /* we always look for replacement on right */
+				if(remove_node == remove_parent) /* special case for root node */
+				{
+					replacement_stack_node->node_ptr = &(map->root);
+				}
+				else
+				{
+					replacement_stack_node->node_ptr = key < remove_parent-> key ? &(remove_parent->left) : &(remove_parent->right);
+				}
+
+				parent_list = replacement_stack_node;
+				
+
+				/*
+				 * put pointer to replacement node->right into list for balance update
+				 * this node will have to be updated with the proper pointer
+				 * after we have identified the replacement
+				 */
+				replacement_stack_node = (stack_node*)malloc(sizeof(stack_node));
+				if(replacement_stack_node == NULL) /* deal with malloc failure */
+				{
+					/* free previous stack nodes to prevent memory leak */
+					free_stack(parent_list);
+					return NULL;
+				}
+
+				replacement_stack_node->previous = parent_list;
+				replacement_stack_node->direction = -1; /* we always look for replacement to left of this node */
+				parent_list = replacement_stack_node;
+				
+				/* find smallest node on right (large) side of tree */
+				replacement_parent = remove_node->right;
+				replacement = replacement_parent->left;
+				
+				while((replacement_next = replacement->left)  != NULL)
+				{
+					next_parent = (stack_node*)malloc(sizeof(stack_node));
+					if(next_parent == NULL) /* deal with malloc failure */
+					{
+						/* free previous stack nodes to prevent memory leak */
+						free_stack(parent_list);
+						return NULL;
+					}
+
+					next_parent->node_ptr = &(replacement_parent->left);
+					next_parent->previous = parent_list;
+					next_parent->direction = -1; /* we always go left */
+					parent_list = next_parent;
+
+					replacement_parent = replacement;
+					replacement = replacement_next;
+
+				}
+
+				replacement_parent->left = replacement->right;
+				
+				replacement->left = remove_node->left;
+				replacement->right = remove_node->right;
+				replacement->balance = remove_node->balance;
+				replacement_stack_node->node_ptr = &(replacement->right);
+			}
+			
+			/* insert replacement at proper location in tree */
+			if(remove_node == remove_parent)
+			{
+				map->root = replacement;
+			}
+			else
+			{
+				remove_parent->left = remove_node == remove_parent->left ? replacement : remove_parent->left;
+				remove_parent->right = remove_node == remove_parent->right ? replacement : remove_parent->right;
+			}
+		
+
+			/* rebalance tree */
+			previous_parent = parent_list;
+			new_balance = 0;
+			while(previous_parent != NULL && new_balance == 0)
+			{
+				new_balance = rebalance(previous_parent->node_ptr, previous_parent->direction, -1);
+				previous_parent = previous_parent->previous;
+			}
+			
+			
+
+
+			/* 
+			 * since we found a value to remove, decrease number of elements in map
+			 *  set return value to the deleted node's value and free the node
+			 */
+			map->num_elements = map->num_elements - 1;
+			value = remove_node->value;
+			free(remove_node);
+		}
+	}
+
+	free_stack(parent_list);
+	
+	return value;
+}
+
+
+/* note: returned keys are dynamically allocated, you need to free them! */
+unsigned long* get_sorted_long_map_keys(long_map* map, unsigned long* num_keys_returned)
+{
+	unsigned long* key_list = (unsigned long*)malloc((map->num_elements)*sizeof(unsigned long));
+	unsigned long next_key_index;
+	if(key_list == NULL)
+	{
+		*num_keys_returned = 0;
+		return NULL;
+	}
+	next_key_index = 0;
+	get_sorted_node_keys(map->root, key_list, &next_key_index, 0);
+	
+	*num_keys_returned = map->num_elements;
+
+	return key_list;
+}
+
+
+void** get_sorted_long_map_values(long_map* map, unsigned long* num_values_returned)
+{
+	void** value_list = (void**)malloc((map->num_elements+1)*sizeof(void*));
+	unsigned long next_value_index;
+
+	if(value_list == NULL)
+	{
+		*num_values_returned = 0;
+		return NULL;
+	}
+	next_value_index = 0;
+	get_sorted_node_values(map->root, value_list, &next_value_index, 0);
+	value_list[map->num_elements] = NULL; /* since we're dealing with pointers make list null terminated */
+
+	*num_values_returned = map->num_elements;
+	return value_list;
+
+}
+
+
+
+void** destroy_long_map(long_map* map, int destruction_type, unsigned long* num_destroyed)
+{
+	void** return_values = destroy_long_map_values(map, destruction_type, num_destroyed);
+	free(map);
+	return return_values;
+}
+
+
+
+void apply_to_every_long_map_value(long_map* map, void (*apply_func)(unsigned long key, void* value))
+{
+	apply_to_every_long_map_node(map->root, apply_func);
+}
+void apply_to_every_string_map_value(string_map* map, void (*apply_func)(char* key, void* value))
+{
+	apply_to_every_string_map_node( (map->lm).root, map->store_keys, apply_func);
+}
+
+
+/***************************************************
+ * internal utility function definitions
+ ***************************************************/
+static void free_stack(stack_node* stack)
+{
+	while(stack != NULL)
+	{
+		stack_node* prev_node = stack;
+		stack = prev_node->previous;
+		free(prev_node);
+	}
+
+}
+
+static void** destroy_long_map_values(long_map* map, int destruction_type, unsigned long* num_destroyed)
+{
+	void** return_values = NULL;
+	unsigned long return_index = 0;
+
+	*num_destroyed = 0;
+
+	if(destruction_type == DESTROY_MODE_RETURN_VALUES)
+	{
+		return_values = (void**)malloc((map->num_elements+1)*sizeof(void*));
+		if(return_values == NULL) /* deal with malloc failure */
+		{
+			destruction_type = DESTROY_MODE_IGNORE_VALUES; /* could cause memory leak, but there's no other way to be sure we won't seg fault */
+		}
+		else
+		{
+			return_values[map->num_elements] = NULL;
+		}
+	}
+	while(map->num_elements > 0)
+	{
+		unsigned long smallest_key;
+		void* removed_value = remove_smallest_long_map_element(map, &smallest_key);
+		if(destruction_type == DESTROY_MODE_RETURN_VALUES)
+		{
+			return_values[return_index] = removed_value;
+		}
+		if(destruction_type == DESTROY_MODE_FREE_VALUES)
+		{
+			free(removed_value);
+		}
+		return_index++;
+		*num_destroyed = *num_destroyed + 1;
+	}
+	return return_values;
+}
+
+static void apply_to_every_long_map_node(long_map_node* node, void (*apply_func)(unsigned long key, void* value))
+{
+	if(node != NULL)
+	{
+		apply_to_every_long_map_node(node->left,  apply_func);
+		
+		apply_func(node->key, node->value);
+
+		apply_to_every_long_map_node(node->right, apply_func);
+	}
+}
+static void apply_to_every_string_map_node(long_map_node* node, unsigned char has_key, void (*apply_func)(char* key, void* value))
+{
+	if(node != NULL)
+	{
+		apply_to_every_string_map_node(node->left, has_key,  apply_func);
+		
+		if(has_key)
+		{
+			string_map_key_value* kv = (string_map_key_value*)(node->value);
+			apply_func(kv->key, kv->value);
+		}
+		else
+		{
+			apply_func(NULL, node->value);
+		}
+		apply_to_every_string_map_node(node->right, has_key, apply_func);
+	}
+}
+
+
+
+static void get_sorted_node_keys(long_map_node* node, unsigned long* key_list, unsigned long* next_key_index, int depth)
+{
+	if(node != NULL)
+	{
+		get_sorted_node_keys(node->left, key_list, next_key_index, depth+1);
+		
+		key_list[ *next_key_index ] = node->key;
+		(*next_key_index)++;
+
+		get_sorted_node_keys(node->right, key_list, next_key_index, depth+1);
+	}
+}
+
+static void get_sorted_node_values(long_map_node* node, void** value_list, unsigned long* next_value_index, int depth)
+{
+	if(node != NULL)
+	{
+		get_sorted_node_values(node->left, value_list, next_value_index, depth+1);
+		
+		value_list[ *next_value_index ] = node->value;
+		(*next_value_index)++;
+
+		get_sorted_node_values(node->right, value_list, next_value_index, depth+1);
+	}
+}
+
+
+
+/*
+ * direction = -1 indicates left subtree updated, direction = 1 for right subtree
+ * update_op = -1 indicates delete node, update_op = 1 for insert node
+ */
+static signed char rebalance (long_map_node** n, signed char direction, signed char update_op)
+{
+	/*
+	printf( "original: key = %ld, balance = %d, update_op=%d, direction=%d\n", (*n)->key, (*n)->balance, update_op, direction); 
+	*/
+
+	(*n)->balance = (*n)->balance + (update_op*direction);
+	
+	if( (*n)->balance <  -1)
+	{
+		if((*n)->left->balance < 0)
+		{
+			rotate_right(n);
+			(*n)->right->balance = 0;
+			(*n)->balance = 0;
+		}
+		else if((*n)->left->balance == 0)
+		{
+			rotate_right(n);
+			(*n)->right->balance = -1;
+			(*n)->balance = 1;
+		}
+		else if((*n)->left->balance > 0)
+		{
+			rotate_left( &((*n)->left) );
+			rotate_right(n);
+			/*
+			if( (*n)->balance < 0 )
+			{
+				(*n)->left->balance = 0;
+				(*n)->right->balance = 1;
+			}
+			else if( (*n)->balance == 0 )
+			{
+				(*n)->left->balance = 0;
+				(*n)->right->balance = 0;
+			}
+			else if( (*n)->balance > 0 )
+			{
+				(*n)->left->balance = -1;
+				(*n)->right->balance = 0;
+			}
+			*/
+			(*n)->left->balance  = (*n)->balance > 0 ? -1 : 0;
+			(*n)->right->balance = (*n)->balance < 0 ?  1 : 0;
+			(*n)->balance = 0;
+		}
+	}
+	if( (*n)->balance >  1)
+	{
+		if((*n)->right->balance > 0)
+		{
+			rotate_left(n);
+			(*n)->left->balance = 0;
+			(*n)->balance = 0;
+		}
+		else if ((*n)->right->balance == 0)
+		{
+			rotate_left(n);
+			(*n)->left->balance = 1;
+			(*n)->balance = -1;
+		}
+		else if((*n)->right->balance < 0)
+		{
+			rotate_right( &((*n)->right) );
+			rotate_left(n);
+			/*
+			if( (*n)->balance < 0 )
+			{
+				(*n)->left->balance = 0;
+				(*n)->right->balance = 1;
+			}
+			else if( (*n)->balance == 0 )
+			{
+				(*n)->left->balance = 0;
+				(*n)->right->balance = 0;
+			}
+			else if( (*n)->balance > 0 )
+			{
+				(*n)->left->balance = -1;
+				(*n)->right->balance = 0;
+			}
+			*/
+			(*n)->left->balance   = (*n)->balance > 0 ? -1 : 0;
+			(*n)->right->balance  = (*n)->balance < 0 ?  1 : 0;
+			(*n)->balance = 0;
+		}
+	}
+
+	/*
+	printf( "key = %ld, balance = %d\n", (*n)->key, (*n)->balance);
+	*/
+
+	return (*n)->balance;
+}
+
+
+static void rotate_right (long_map_node** parent)
+{
+	long_map_node* old_parent = *parent;
+	long_map_node* pivot = old_parent->left;
+	old_parent->left = pivot->right;
+	pivot->right  = old_parent;
+	
+	*parent = pivot;
+}
+
+static void rotate_left (long_map_node** parent)
+{
+	long_map_node* old_parent = *parent;
+	long_map_node* pivot = old_parent->right;
+	old_parent->right = pivot->left;
+	pivot->left  = old_parent;
+	
+	*parent = pivot;
+}
+
+
+
+/***************************************************************************
+ * This algorithm was created for the sdbm database library (a public-domain 
+ * reimplementation of ndbm) and seems to work relatively well in 
+ * scrambling bits
+ *
+ *
+ * This code was derived from code found at:
+ * http://www.cse.yorku.ca/~oz/hash.html
+ ***************************************************************************/
+static unsigned long sdbm_string_hash(const char *key)
+{
+	unsigned long hashed_key = 0;
+
+	int index = 0;
+	unsigned int nextch;
+	while(key[index] != '\0')
+	{
+		nextch = key[index];
+		hashed_key = nextch + (hashed_key << 6) + (hashed_key << 16) - hashed_key;
+		index++;
+	}
+	return hashed_key;
+}
+
+
--- /dev/null
+++ b/net/netfilter/xt_weburl.c
@@ -0,0 +1,411 @@
+/*  weburl --	A netfilter module to match URLs in HTTP requests
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright © 2008-2010 by Eric Bishop <eric@gargoyle-router.com>
+ *
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <net/sock.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter/xt_weburl.h>
+
+#include "regexp/regexp.c"
+#include "weburl_deps/tree_map.h"
+
+
+#include <linux/ip.h>
+
+
+#include <linux/netfilter/x_tables.h>
+
+
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("xt_weburl");
+MODULE_ALIAS("ipt_weburl");
+MODULE_ALIAS("ip6t_weburl");
+MODULE_AUTHOR("Eric Bishop");
+MODULE_DESCRIPTION("Match URL in HTTP requests, designed for use with Gargoyle web interface (www.gargoyle-router.com)");
+
+string_map* compiled_map = NULL;
+
+int strnicmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count)
+	{
+		if ((__res = toupper( *cs ) - toupper( *ct++ ) ) != 0 || !*cs++)
+		{
+			break;
+		}
+		count--;
+	}
+	return __res;
+}
+
+char *strnistr(const char *s, const char *find, size_t slen)
+{
+	char c, sc;
+	size_t len;
+
+
+	if ((c = *find++) != '\0')
+	{
+		len = strlen(find);
+		do
+		{
+			do
+			{
+      				if (slen < 1 || (sc = *s) == '\0')
+				{
+      					return (NULL);
+				}
+      				--slen;
+      				++s;
+      			}
+			while ( toupper(sc) != toupper(c));
+      			
+			if (len > slen)
+			{
+      				return (NULL);
+			}
+      		}
+		while (strnicmp(s, find, len) != 0);
+      		
+		s--;
+      	}
+      	return ((char *)s);
+}
+
+
+int do_match_test(unsigned char match_type,  const char* reference, char* query)
+{
+	int matches = 0;
+	struct regexp* r;
+	switch(match_type)
+	{
+		case WEBURL_CONTAINS_TYPE:
+			matches = (strstr(query, reference) != NULL);
+			break;
+		case WEBURL_REGEX_TYPE:
+
+			if(compiled_map == NULL)
+			{
+				compiled_map = initialize_map(0);
+				if(compiled_map == NULL) /* test for malloc failure */
+				{
+					return 0;
+				}
+			}
+			r = (struct regexp*)get_map_element(compiled_map, reference);
+			if(r == NULL)
+			{
+				int rlen = strlen(reference);
+				r= regcomp((char*)reference, &rlen);
+				if(r == NULL) /* test for malloc failure */
+				{
+					return 0;
+				}
+				set_map_element(compiled_map, reference, (void*)r);
+			}
+			matches = regexec(r, query);
+			break;
+		case WEBURL_EXACT_TYPE:
+			matches = (strstr(query, reference) != NULL) && strlen(query) == strlen(reference);
+			break;
+	}
+	return matches;
+}
+
+int http_match(const struct ipt_weburl_info* info, const unsigned char* packet_data, int packet_length)
+{
+	int test = 0; 
+
+	
+	/* first test if we're dealing with a web page request */
+	if(strnicmp((char*)packet_data, "GET ", 4) == 0 || strnicmp(  (char*)packet_data, "POST ", 5) == 0 || strnicmp((char*)packet_data, "HEAD ", 5) == 0)
+	{
+
+		/* printk("found a  web page request\n"); */
+		char path[625] = "";
+		char host[625] = "";
+		int path_start_index;
+		int path_end_index;
+		int last_header_index;
+		char last_two_buf[2];
+		int end_found;
+		char* host_match;
+		char* test_prefixes[6];
+		int prefix_index;
+	
+
+		/* get path portion of URL */
+		path_start_index = (int)(strstr((char*)packet_data, " ") - (char*)packet_data);
+		while( packet_data[path_start_index] == ' ')
+		{
+			path_start_index++;
+		}
+		path_end_index= (int)(strstr( (char*)(packet_data+path_start_index), " ") -  (char*)packet_data);
+		if(path_end_index > 0) 
+		{
+			int path_length = path_end_index-path_start_index;
+			path_length = path_length < 625 ? path_length : 624; /* prevent overflow */
+			memcpy(path, packet_data+path_start_index, path_length);
+			path[ path_length] = '\0';
+		}
+		
+		/* get header length */
+		last_header_index = 2;
+		memcpy(last_two_buf,(char*)packet_data, 2);
+		end_found = 0;
+		while(end_found == 0 && last_header_index < packet_length)
+		{
+			char next = (char)packet_data[last_header_index];
+			if(next == '\n')
+			{
+				end_found = last_two_buf[1] == '\n' || (last_two_buf[0] == '\n' && last_two_buf[1] == '\r') ? 1 : 0;
+			}
+			if(end_found == 0)
+			{
+				last_two_buf[0] = last_two_buf[1];
+				last_two_buf[1] = next;
+				last_header_index++;
+			}
+		}
+		
+		/* get host portion of URL */
+		host_match = strnistr( (char*)packet_data, "Host:", last_header_index);
+		if(host_match != NULL)
+		{
+			int host_end_index;
+			host_match = host_match + 5; /* character after "Host:" */
+			while(host_match[0] == ' ')
+			{
+				host_match = host_match+1;
+			}
+			
+			host_end_index = 0;
+			while(	host_match[host_end_index] != '\n' && 
+				host_match[host_end_index] != '\r' && 
+				host_match[host_end_index] != ' ' && 
+				host_match[host_end_index] != ':' && 
+				((char*)host_match - (char*)packet_data)+host_end_index < last_header_index 
+				)
+			{
+				host_end_index++;
+			}
+			memcpy(host, host_match, host_end_index);
+			host_end_index = host_end_index < 625 ? host_end_index : 624; /* prevent overflow */
+			host[host_end_index] = '\0';
+
+			
+		}
+	
+		// printk("host = \"%s\", path =\"%s\"\n", host, path); 
+		
+
+		switch(info->match_part)
+		{
+			case WEBURL_DOMAIN_PART:
+				test = do_match_test(info->match_type, info->test_str, host);
+				if(!test && strstr(host, "www.") == host)
+				{
+					test = do_match_test(info->match_type, info->test_str, ((char*)host+4) );	
+				}
+				break;
+			case WEBURL_PATH_PART:
+				test = do_match_test(info->match_type, info->test_str, path);
+				if( !test && path[0] == '/' )
+				{
+					test = do_match_test(info->match_type, info->test_str, ((char*)path+1) );
+				}
+				break;
+			case WEBURL_ALL_PART:
+				
+				test_prefixes[0] = "http://";
+				test_prefixes[1] = "";
+				test_prefixes[2] = NULL;
+
+				
+				for(prefix_index=0; test_prefixes[prefix_index] != NULL && test == 0; prefix_index++)
+				{
+					char test_url[1250];
+					test_url[0] = '\0';
+					strcat(test_url, test_prefixes[prefix_index]);
+					strcat(test_url, host);
+					if(strcmp(path, "/") != 0)
+					{
+						strcat(test_url, path);
+					}
+					test = do_match_test(info->match_type, info->test_str, test_url);
+					if(!test && strcmp(path, "/") == 0)
+					{
+						strcat(test_url, path);
+						test = do_match_test(info->match_type, info->test_str, test_url);
+					}
+					
+					/* printk("test_url = \"%s\", test=%d\n", test_url, test); */
+				}
+				if(!test && strstr(host, "www.") == host)
+				{
+					char* www_host = ((char*)host+4);
+					for(prefix_index=0; test_prefixes[prefix_index] != NULL && test == 0; prefix_index++)
+					{
+						char test_url[1250];
+						test_url[0] = '\0';
+						strcat(test_url, test_prefixes[prefix_index]);
+						strcat(test_url, www_host);
+						if(strcmp(path, "/") != 0)
+						{
+							strcat(test_url, path);
+						}
+						test = do_match_test(info->match_type, info->test_str, test_url);
+						if(!test && strcmp(path, "/") == 0)
+						{
+							strcat(test_url, path);
+							test = do_match_test(info->match_type, info->test_str, test_url);
+						}
+					
+						/* printk("test_url = \"%s\", test=%d\n", test_url, test); */
+					}
+				}
+				break;
+			
+		}		
+
+
+		/* 
+		 * If invert flag is set, return true if this IS a web request, but it didn't match 
+		 * Always return false for non-web requests
+		 */
+		test = info->invert ? !test : test;
+	}
+
+	return test;
+}
+
+static bool match(const struct sk_buff *skb, struct xt_action_param *par)
+{
+
+	const struct ipt_weburl_info *info = (const struct ipt_weburl_info*)(par->matchinfo);
+	struct tcphdr* tcp_hdr = NULL;
+	unsigned char* payload = NULL;
+	unsigned short payload_length = 0;
+
+	
+	int test = 0;
+
+	/* linearize skb if necessary */
+	struct sk_buff *linear_skb;
+	int skb_copied;
+
+
+	if(skb_is_nonlinear(skb))
+	{
+		linear_skb = skb_copy(skb, GFP_ATOMIC);
+		skb_copied = 1;
+	}
+	else
+	{
+		linear_skb = (struct sk_buff*)skb;
+		skb_copied = 0;
+	}
+
+
+	/* get payload */
+	tcp_hdr		= (struct tcphdr*)skb_transport_header(skb);
+	payload 		= (unsigned char *)tcp_hdr + tcp_hdrlen(skb);
+	payload_length	= skb_tail_pointer(skb) - ((unsigned char *)tcp_hdr + tcp_hdrlen(skb));
+
+
+	/* if payload length <= 10 bytes don't bother doing a check, otherwise check for match */
+	if(payload_length > 10)
+	{
+		test = http_match(info, payload, payload_length);
+	}
+	
+	/* free skb if we made a copy to linearize it */
+	if(skb_copied == 1)
+	{
+		kfree_skb(linear_skb);
+	}
+
+
+	/* printk("returning %d from weburl\n\n\n", test); */
+	return test;
+}
+
+
+static int checkentry(const struct xt_mtchk_param *par)
+{
+	return 0;
+}
+
+
+static struct xt_match weburl_matches[]  __read_mostly  = {
+	{
+		.name		= "weburl",
+		.match		= &match,
+		.family		= NFPROTO_IPV4,
+		.matchsize	= sizeof(struct ipt_weburl_info),
+		.checkentry	= &checkentry,
+		.proto          = IPPROTO_TCP,
+		.me		= THIS_MODULE,
+	},
+	{
+		.name           = "weburl",
+		.match          = &match,
+		.family         = NFPROTO_IPV6,
+		.matchsize      = sizeof(struct ipt_weburl_info),
+		.checkentry     = &checkentry,
+		.proto          = IPPROTO_TCP,
+		.me             = THIS_MODULE,
+	}
+};
+
+
+static int __init init(void)
+{
+	compiled_map = NULL;
+	return xt_register_matches(weburl_matches, ARRAY_SIZE(weburl_matches));
+
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_matches(weburl_matches, ARRAY_SIZE(weburl_matches));
+	if(compiled_map != NULL)
+	{
+		unsigned long num_destroyed;
+		destroy_map(compiled_map, DESTROY_MODE_FREE_VALUES, &num_destroyed);
+	}
+}
+
+module_init(init);
+module_exit(fini);
+
